import torchimport torch.nn as nnimport torch.nn.functional as Fimport numpy as npclass EnsembleNet(nn.Module):    def __init__(self, model_list, weight):        super(EnsembleNet,self).__init__()        self.num_models = len(model_list)        self.models = nn.ModuleList(model_list)        self.weight = weight    def forward(self,x):        for i in range(self.num_models):            if i==0:                output = self.models[i](x)*self.weight[i]            else:                output += self.models[i](x)*self.weight[i]        output/= np.sum(self.weight)        return outputclass EnsembleSegNet(nn.Module):    def __init__(self, model_list, weight):        super(EnsembleSegNet,self).__init__()        self.num_models = len(model_list)        self.models = nn.ModuleList(model_list)        self.weight = weight    def forward(self,x,mask):        for i in range(self.num_models):            if i==0:                output = self.models[i](x,mask)*self.weight[i]            else:                output += self.models[i](x,mask)*self.weight[i]        output/= np.sum(self.weight)        return outputclass Multiscale(nn.Module):    def __init__(self, model, scales = (0.9,1.,1.1)):        super(Multiscale,self).__init__()        self.scales = scales        self.model = model    def forward(self,x):        for i in range(len(self.scales)):            x_s = F.interpolate(x,scale_factor=self.scales[i], mode='bilinear',align_corners=True)            if i==0:                output = self.model(x_s)            else:                output += self.model(x_s)        output/= len(self.scales)        return outputclass MultiscaleSeg(nn.Module):    def __init__(self, model, scales = (0.9,1.,1.1)):        super(MultiscaleSeg,self).__init__()        self.scales = scales        self.model = model    def forward(self,x,mask):        for i in range(len(self.scales)):            x_s = F.interpolate(x,scale_factor=self.scales[i], mode='bilinear',align_corners=True)            mask_s = F.interpolate(x,scale_factor=self.scales[i], mode='nearest',align_corners=True)            if i==0:                output = self.model(x_s,mask_s)            else:                output += self.model(x_s,mask_s)        output/= len(self.scales)        return output